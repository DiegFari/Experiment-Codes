---
title: "research-project"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Loading necessary libraries
library(dplyr)
library(ggplot2)
library(tidyverse)
library(broom)
library(lme4)
library(boot)
library(ordinal)
```

## Research Project

### Data Formatting

```{r}
# Set working directory to source file location

# Documentation function to read in PCIbex Farm results files (source: https://doc.pcibex.net/advanced-tutorial/12_examining-data.html#reading-in-results):
read.pcibex <- function(filepath, fun.col=function(col,cols){cols[cols==col]<-paste(col,"Ibex",sep=".");return(cols)}) {
  n.cols <- max(count.fields(filepath,sep=",",quote=NULL),na.rm=TRUE)
  
  cols <- c()
    con <- file(filepath, "r")
    while ( TRUE ) {
      line <- readLines(con, n = 1, warn=FALSE)
      if ( length(line) == 0) {
        break
      }
      m <- regmatches(line,regexec("^# (\\d+)\\. (.+)\\.$",line))[[1]]
      if (length(m) == 3) {
        index <- as.numeric(m[2])
        value <- m[3]
        if (is.function(fun.col)){
         cols <- fun.col(value,cols)
        }
        cols[index] <- value
        if (index == n.cols){
          break
        }
      }
    }
    
    close(con)
    
    return(read.csv(filepath, comment.char="#", header=FALSE, col.names=cols, colClasses="character"))
}

# Function to format PCIbex Farm results files:
format.pcibex <- function(results, group) {
  formatted_results <- results %>% 
    # 1. Rename columns for easier handling
    rename(Subject = MD5.hash.of.participant.s.IP.address, ItemNumber = Order.number.of.item, ItemType = Label, Age = age, Gender = gender, Occupation = occupation, Nationality = nationality) %>% 
    # 2. Remove irrelevant columns
    select(-Results.reception.time, -Controller.name, -Inner.element.number, -Latin.Square.Group, -Comments, -PennElementType) %>% 
    # 3. Remove irrelevant sections of the experiment
    filter(ItemType %in% c('personal-info', 'experiment', 'manipulation-check', 'sd-bias')) %>% 
    # 4. Remove rows generated by the timer (we will calculate RT ourselves)
    filter(PennElementName != 'RT') %>%
    # 5. Remove other unnecessary rows generated by PCIbex
    filter(Value != 'End' | ItemType == 'experiment') %>%
    filter(Value != 'Start' | ItemType %in% c('experiment', 'personal-info')) %>%
    # 7. Add an additional column with the specific group (high sd vs. low sd)
    mutate(Group = group) %>% 
    # 9. Some columns were not added correctly and were instead added as extra rows. Shift them into their own columns.
    mutate(Question = ifelse(ItemType == 'experiment', Age, NA), Age = ifelse(ItemType == 'personal-info', Age, NA)) %>% 
    mutate(QuestionType = ifelse(ItemType == 'experiment', Gender, NA), Gender = ifelse(ItemType == 'personal-info', Gender, NA)) %>% 
    mutate(Occupation = ifelse(ItemType == 'personal-info', Occupation, NA), Nationality = ifelse(ItemType == 'personal-info', Nationality, NA)) %>% 
    # 10. Repeat the same value for these columns for all rows specific to a subject
    group_by(Subject) %>%
    mutate(Age = first(Age), Gender = first(Gender), Occupation = first(Occupation), Nationality = first(Nationality)) %>%
    ungroup()
  
  return(formatted_results)
}

# Read in result files:
results_high_sd <- read.pcibex("results_high_sd.csv") %>% format.pcibex('high-sd')

results_low_sd <- read.pcibex("results_low_sd.csv") %>% format.pcibex('low-sd')

results <- bind_rows(results_high_sd, results_low_sd)

results
```

### Demographics Analysis

```{r}
# Age percentages:
age_summary <- results %>%
  # 1. Select only one value per subject 
  distinct(Subject, Age) %>%
  # 2. Prepare data for comparison 
  mutate(Age = as.numeric(trimws(Age))) %>% 
  # 3. Divide into groups
  mutate(Age = ifelse(Age > 30, "Over 30", "30 and Under")) %>% 
  # 4. Calculate percentage and sort
  group_by(Age) %>%
  summarize(
    Count = n(), 
    Percentage = round((n() / n_distinct(results$Subject)) * 100, 1)
  ) %>%
  arrange(desc(Percentage))

print(age_summary)

# Gender percentages:
gender_summary <- results %>%
  # 1. Select only one value per subject 
  distinct(Subject, Gender) %>% 
  # 2. Prepare data for comparison 
  mutate(Gender = tolower(Gender)) %>% 
  # 3. Calculate percentage and sort
  group_by(Gender) %>%
  summarize(
    Count = n(), 
    Percentage = round((n() / n_distinct(results$Subject)) * 100, 1)
  ) %>%
  arrange(desc(Percentage))

print(gender_summary)

# Occupation percentages:
occupation_summary <- results %>%
  # 1. Select only one value per subject 
  distinct(Subject, Occupation) %>% 
  # 2. Prepare data for comparison 
  mutate(Occupation = tolower(Occupation), Occupation = case_when(grepl("student", Occupation) ~ "student", TRUE ~ Occupation)) %>%
  # 3. Calculate percentage and sort
  group_by(Occupation) %>%
  summarize(
    Count = n(), 
    Percentage = round((n() / n_distinct(results$Subject)) * 100, 1)
  ) %>%
  arrange(desc(Percentage))

print(occupation_summary)

# Nationality percentages:
nationality_summary <- results %>%
  # 1. Select only one value per subject 
  distinct(Subject, Nationality) %>% 
  # 2. Prepare data for comparison 
  mutate(Nationality = tolower(Nationality), Nationality = case_when(grepl("italian", Nationality) ~ "italian", grepl("nl", Nationality) ~ "dutch", grepl("peru", Nationality) ~ "peruvian", TRUE ~ Nationality)) %>% 
  # 3. Calculate percentage and sort
  group_by(Nationality) %>%
  summarize(
    Count = n(), 
    Percentage = round((n() / n_distinct(results$Subject)) * 100, 1)
  ) %>%
  arrange(desc(Percentage))

# Group percentages:
group_summary <- results %>%
  # 1. Select only one value per subject 
  distinct(Subject, Group) %>%
  # 2. Calculate percentage and sort
  group_by(Group) %>%
  summarize(
    Count = n(), 
    Percentage = round((n() / n_distinct(results$Subject)) * 100, 1)
  ) %>%
  arrange(desc(Percentage))

print(group_summary)
```

### Response Times Calculation

```{r}
# RTs for every question for every subject:
results_with_rt <- results %>%
  # 1. Prepare EventTime for numerical comparison
  mutate(EventTime = as.numeric(trimws(EventTime))) %>% 
  # 2. Select only experiment rows marked as "Start" and "End" 
  filter(ItemType == "experiment" & Value %in% c("Start", "End")) %>%
  # 3. Calculate RT by subtracting EventTime values from "Start" and "End"
  select(Subject, Question, Value, EventTime) %>%
  pivot_wider(names_from = Value, values_from = EventTime) %>%
  mutate(RT = as.character(End - Start))

results <- results %>% 
  # 4. Add new RT column to results
  left_join(results_with_rt, by = c("Subject", "Question")) %>%
  # 5. Remove experiment rows marked as "Start" and "End" (they are now irrelevant)
  filter(!Value %in% c("Start", "End") | ItemType == "personal-info") %>% 
  # 6. Remove irrelevant columns
  select(-Start, -End, -EventTime)

results
```

### Answer Switches Calculation

```{r}
# Answer switches for every question for every subject:
results_answer_switches <- results %>%
  # 1. Select only recorded answers for every experiment questions
  filter(ItemType == "experiment" & Parameter == "Choice") %>% 
  # 2. Count how many instances per subject per question
  count(Subject, Question)

results <- results %>% 
  # 3. Add answer switches count to results
  left_join(results_answer_switches, by = c("Subject", "Question")) %>%
  # 4. Rename new column to AnswerSwitches
  rename(AnswerSwitches = n) %>% 
  # 5. Remove experiment rows marked as "Choice" (they are now irrelevant)
  filter(Parameter != "Choice" | ItemType != "experiment")

results
```

